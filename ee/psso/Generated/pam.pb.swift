// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: pam.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

internal import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum InteractiveAuthResult: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case pamSuccess // = 0
  case pamPermDenied // = 6
  case pamAuthErr // = 7
  case UNRECOGNIZED(Int)

  init() {
    self = .pamSuccess
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .pamSuccess
    case 6: self = .pamPermDenied
    case 7: self = .pamAuthErr
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .pamSuccess: return 0
    case .pamPermDenied: return 6
    case .pamAuthErr: return 7
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [InteractiveAuthResult] = [
    .pamSuccess,
    .pamPermDenied,
    .pamAuthErr,
  ]

}

struct TokenAuthRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var username: String = String()

  var token: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct TokenAuthResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var successful: Bool = false

  var token: Token {
    get {return _token ?? Token()}
    set {_token = newValue}
  }
  /// Returns true if `token` has been explicitly set.
  var hasToken: Bool {return self._token != nil}
  /// Clears the value of `token`. Subsequent reads from it will return its default value.
  mutating func clearToken() {self._token = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _token: Token? = nil
}

struct InteractiveAuthInitRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var username: String = String()

  var password: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct InteractiveAuthContinueRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var txid: String = String()

  var value: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct InteractiveAuthRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var interactiveAuth: InteractiveAuthRequest.OneOf_InteractiveAuth? = nil

  var init_p: InteractiveAuthInitRequest {
    get {
      if case .init_p(let v)? = interactiveAuth {return v}
      return InteractiveAuthInitRequest()
    }
    set {interactiveAuth = .init_p(newValue)}
  }

  var `continue`: InteractiveAuthContinueRequest {
    get {
      if case .continue(let v)? = interactiveAuth {return v}
      return InteractiveAuthContinueRequest()
    }
    set {interactiveAuth = .continue(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_InteractiveAuth: Equatable, Sendable {
    case init_p(InteractiveAuthInitRequest)
    case `continue`(InteractiveAuthContinueRequest)

  }

  init() {}
}

struct InteractiveChallenge: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var txid: String = String()

  var finished: Bool = false

  var result: InteractiveAuthResult = .pamSuccess

  var prompt: String = String()

  var promptMeta: InteractiveChallenge.PromptMeta = .unspecified

  var debugInfo: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum PromptMeta: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case unspecified // = 0
    case pamPromptEchoOff // = 1
    case pamPromptEchoOn // = 2
    case pamErrorMsg // = 3
    case pamTextInfo // = 4
    case pamRadioType // = 5
    case pamBinaryPrompt // = 7
    case password // = 100
    case UNRECOGNIZED(Int)

    init() {
      self = .unspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .pamPromptEchoOff
      case 2: self = .pamPromptEchoOn
      case 3: self = .pamErrorMsg
      case 4: self = .pamTextInfo
      case 5: self = .pamRadioType
      case 7: self = .pamBinaryPrompt
      case 100: self = .password
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .pamPromptEchoOff: return 1
      case .pamPromptEchoOn: return 2
      case .pamErrorMsg: return 3
      case .pamTextInfo: return 4
      case .pamRadioType: return 5
      case .pamBinaryPrompt: return 7
      case .password: return 100
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [InteractiveChallenge.PromptMeta] = [
      .unspecified,
      .pamPromptEchoOff,
      .pamPromptEchoOn,
      .pamErrorMsg,
      .pamTextInfo,
      .pamRadioType,
      .pamBinaryPrompt,
      .password,
    ]

  }

  init() {}
}

struct PAMAuthorizationResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var response: AuthorizeResponse {
    get {return _response ?? AuthorizeResponse()}
    set {_response = newValue}
  }
  /// Returns true if `response` has been explicitly set.
  var hasResponse: Bool {return self._response != nil}
  /// Clears the value of `response`. Subsequent reads from it will return its default value.
  mutating func clearResponse() {self._response = nil}

  var code: InteractiveAuthResult = .pamSuccess

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _response: AuthorizeResponse? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "pam"

extension InteractiveAuthResult: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0PAM_SUCCESS\0\u{2}\u{6}PAM_PERM_DENIED\0\u{1}PAM_AUTH_ERR\0")
}

extension TokenAuthRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TokenAuthRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}username\0\u{1}token\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.username) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.token) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 1)
    }
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TokenAuthRequest, rhs: TokenAuthRequest) -> Bool {
    if lhs.username != rhs.username {return false}
    if lhs.token != rhs.token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TokenAuthResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TokenAuthResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}successful\0\u{1}token\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.successful) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._token) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.successful != false {
      try visitor.visitSingularBoolField(value: self.successful, fieldNumber: 1)
    }
    try { if let v = self._token {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TokenAuthResponse, rhs: TokenAuthResponse) -> Bool {
    if lhs.successful != rhs.successful {return false}
    if lhs._token != rhs._token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension InteractiveAuthInitRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InteractiveAuthInitRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}username\0\u{1}password\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.username) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.password) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 1)
    }
    if !self.password.isEmpty {
      try visitor.visitSingularStringField(value: self.password, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: InteractiveAuthInitRequest, rhs: InteractiveAuthInitRequest) -> Bool {
    if lhs.username != rhs.username {return false}
    if lhs.password != rhs.password {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension InteractiveAuthContinueRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InteractiveAuthContinueRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}txid\0\u{1}value\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.txid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.txid.isEmpty {
      try visitor.visitSingularStringField(value: self.txid, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: InteractiveAuthContinueRequest, rhs: InteractiveAuthContinueRequest) -> Bool {
    if lhs.txid != rhs.txid {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension InteractiveAuthRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InteractiveAuthRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}init\0\u{1}continue\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: InteractiveAuthInitRequest?
        var hadOneofValue = false
        if let current = self.interactiveAuth {
          hadOneofValue = true
          if case .init_p(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.interactiveAuth = .init_p(v)
        }
      }()
      case 2: try {
        var v: InteractiveAuthContinueRequest?
        var hadOneofValue = false
        if let current = self.interactiveAuth {
          hadOneofValue = true
          if case .continue(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.interactiveAuth = .continue(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.interactiveAuth {
    case .init_p?: try {
      guard case .init_p(let v)? = self.interactiveAuth else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .continue?: try {
      guard case .continue(let v)? = self.interactiveAuth else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: InteractiveAuthRequest, rhs: InteractiveAuthRequest) -> Bool {
    if lhs.interactiveAuth != rhs.interactiveAuth {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension InteractiveChallenge: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InteractiveChallenge"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}txid\0\u{1}finished\0\u{1}result\0\u{1}prompt\0\u{3}prompt_meta\0\u{3}debug_info\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.txid) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.finished) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.prompt) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.promptMeta) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.debugInfo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.txid.isEmpty {
      try visitor.visitSingularStringField(value: self.txid, fieldNumber: 1)
    }
    if self.finished != false {
      try visitor.visitSingularBoolField(value: self.finished, fieldNumber: 2)
    }
    if self.result != .pamSuccess {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 3)
    }
    if !self.prompt.isEmpty {
      try visitor.visitSingularStringField(value: self.prompt, fieldNumber: 4)
    }
    if self.promptMeta != .unspecified {
      try visitor.visitSingularEnumField(value: self.promptMeta, fieldNumber: 5)
    }
    if !self.debugInfo.isEmpty {
      try visitor.visitSingularStringField(value: self.debugInfo, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: InteractiveChallenge, rhs: InteractiveChallenge) -> Bool {
    if lhs.txid != rhs.txid {return false}
    if lhs.finished != rhs.finished {return false}
    if lhs.result != rhs.result {return false}
    if lhs.prompt != rhs.prompt {return false}
    if lhs.promptMeta != rhs.promptMeta {return false}
    if lhs.debugInfo != rhs.debugInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension InteractiveChallenge.PromptMeta: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0UNSPECIFIED\0\u{1}PAM_PROMPT_ECHO_OFF\0\u{1}PAM_PROMPT_ECHO_ON\0\u{1}PAM_ERROR_MSG\0\u{1}PAM_TEXT_INFO\0\u{1}PAM_RADIO_TYPE\0\u{2}\u{2}PAM_BINARY_PROMPT\0\u{2}]\u{1}PASSWORD\0")
}

extension PAMAuthorizationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PAMAuthorizationResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}response\0\u{1}code\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._response) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._response {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.code != .pamSuccess {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PAMAuthorizationResponse, rhs: PAMAuthorizationResponse) -> Bool {
    if lhs._response != rhs._response {return false}
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
